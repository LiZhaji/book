第四版

# 三. 语言基础

## 数据类型

### number数值

会尽可能处理为整数。因为浮点数比整数要多一倍的存储空间。

八进制 数字0开头（严格模式下 语法错误，使用0o）

十六进制 0x开头

最后都以十进制表示



转化方式

- Number()  规则同等与 +
  规则：

1. 1. 有效数值 （正负、不同进制、科学计数法）-> 数值
   2. 布尔值 true -> 1； false -> 0
   3. 字符串

1. 1. 1. 空 '' / '  ' -> 0
      2. 正负不同进制的有效数值，如0xF/1.3/010 -> 数值，忽略前面的0，忽略0开头的八进制，忽略0o开头的负八进制
      3. 包含以上别的字符，都转化为NaN

1. 1. 对象，调用valueOf方法并按上述规则转换，如果是NaN，再调用toString，按字符串规则转换

```js
Number(true) // 1
Number(' ') // 0
Number('1.2') // 1.2
Number('1.2.3') // NaN
Number('010') // 10
Number(010) // 8
Number('0xf') // 15
Number('null') // NaN
Number(null) // 0
Number(undefined) // NaN
```

- parseInt(val, radix)

忽略开头的空格，开头只能是有效的整数字符（加减号/数值字符），解析到末尾或者无效的整数字符为止（小数点/空格/字母）并默认显示为十进制。第二个参数用来指定底数，即告诉它传入的字符串是几进制的。

```js
parseInt('') // NaN 不同于Number
parseInt('1.2.3') // 1
parseInt('10') // 10
parseInt('10', 8) // 8 等同于 parseInt('010')

parseInt(true) // NaN 不同于Number
parseInt(null) // NaN 不同于Number

parseInt(3e2) // 300
parseInt('3e2') // 3
```



- parseFloat(val)
  与parseInt规则类似，区别是有效字符多了个小数点，并且只能传入一个参数，因为只解析十进制。
  传入十六进制始终返回0
- num.toString(radix)

转换为num的radix进制数

### Symbol

常用内置符号，暴露语言内部行为。

- Symbol.iterator `for-of` 时调用的函数，一个以`Symbol.iterator`为键的方法，返回默认的迭代器。实现迭代器API
- Symbol.asyncIterator `for-await-of` 时
- Symbol.hasInstance `a instanceof b` 时b调用
- Symbol.match `str.match(reg)` 时调用，reg不是正则表达式时，会被转换为RegExp对象
- Symbol.replace `str.replace(target, replacement)` 时调用，target不是正则表达式时，会被转换为RegExp对象
- Symbol.search`str.search(reg)` 时调用，reg不是正则表达式时，会被转换为RegExp对象
- Symbol.split `str.split(sign)`
- Symbol.toPrimitive 由`ToPrimitive` 抽象操作使用。 一个方法，将对象转为相应的原始值
- Symbol.toStringTag = xxx `toString()`  [Object xxx]
- Symbol.unscopables  =  {foo: true} 设置为true 阻止指定属性（这里是foo）出现在with环境绑定中。不推荐使用。



## 操作符

一元操作符：递增++/递减--（前缀/后缀）、加+减-、位



- 位操作符：数值底层操作，操作内存中表述数据的比特（位）。先把值转化为32位整数，位操作后把结果转换位64位。

有符号整数和无符号整数。区别在于第三十二位表示的是数值还是符号。0正1负。



18的二进制为：`(18).toString(2)` 10010，其余用0补位

`0000 0000 0000 0000 0000 0000 0001 0010`

反码（一补数）：0变1，1变0。值为 `-n - 1`

补码（二补数）：反码+1，用来表示负数 值为 `-n`

- - 按位非`~`  取反码。实际结果：`-n - 1`
  - 按位与`&` (1 1 为1，其余为0) 、按位或`|`(0 0 为0，其余为1) 、按位异或`^` (不一样时为1，其余为0)
  - 有符号左移`<<` 按照指定位数向左移动。n << d 实际结果：`n * 2^d` 保留符号位 ，但可能会出现负数
  - 有符号右移 `>>` 向右移动 n >>d 实际结果：`n * 2^-d`
  - 无符号右移`>>>` 正数结果相同，但会把负数的第三十二位1当成正数处理，右移后补0，所以数值会很大

```js
34 << 26 // -2013265920 因为第三十二位变成了1，所以这个数就变成了负数
-64 >> 5 // -2
-64 >>> 5 // 134217726
```

为什么没有无符号左移？
因为左移是右边补0，右移是左边补0，所以右移会产生是否保留符号位的问题，左移不会产生符号位问题，所以没必要无符号左移，等同于有符号左移



- 布尔操作符：

- - && 返回的不一定是布尔值！！！有一个false就是false。 第一个为true，返回第二个；第一个为false，返回第一个，不会执行到第二个。
    第一个值为假值 null / NaN / undefined，就返回该值。因为这些都是假值
    **短路操作符**
  - || 有一个true就为true **短路操作符**

```js
null && undefined // null
NaN && null // NaN
'' && undefined // ""
```



- 指数操作符：

- - `**` 等同于 `Math.pow(a, b)` es7
  - `**=` 等同于 a = a ** b 指数赋值操作符



- 复合赋值：

`a += 1; a <<= 1;...` 只是简写，不会提升性能

- 逗号操作符：

可以用来赋值，返回表达式最后一个值。

```js
let num = (1, 2, 3) // 3
```



## 语句



流控制语句：



- if-else/ else-if
- for/ for-in /for-of/ for-await-of
- while/ do-while
- switch-case
- 标签 / break/ continue
- with (不推荐使用，影响性能且难以调试)



## 函数



所有参数都是按值传递的。变量访问则有按值访问和按引用（指针）访问

### 标签函数

```js
// 标签函数
function tagfn(string,...arg){
  console.log(string)
  console.log(arg)
}
tagfn(`ssss`,1,2)
const a = 'aa'
const b = 'bb'
tagfn`a is ${a}, b is ${b}, hhhaa, ${a + b}`
/*
 ["a is ", ", b is ", ", hhhaa, ", ""]
 ["aa", "bb", "aabb"]
 */
```

String.raw`template`

能保留原始字符不被转换，如\n \nbsp

```js
String.raw`a is ${a}, b is ${b}, hhhaa, \n${a + b}`
/*
"a is aa, b is bb, hhhaa, \naabb"
*/

`a is ${a}, b is ${b}, hhhaa, \n${a + b}`
/*
"a is aa, b is bb, hhhaa, 
aabb"
*/
```
